/*
  +--------------------------------------------------------------------------+
  | libcat                                                                   |
  +--------------------------------------------------------------------------+
  | Licensed under the Apache License, Version 2.0 (the "License");          |
  | you may not use this file except in compliance with the License.         |
  | You may obtain a copy of the License at                                  |
  | http://www.apache.org/licenses/LICENSE-2.0                               |
  | Unless required by applicable law or agreed to in writing, software      |
  | distributed under the License is distributed on an "AS IS" BASIS,        |
  | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
  | See the License for the specific language governing permissions and      |
  | limitations under the License. See accompanying LICENSE file.            |
  +--------------------------------------------------------------------------+
  | Author: Twosee <twosee@php.net>                                          |
  |         dixyes <dixyes@gmail.com>                                        |
  +--------------------------------------------------------------------------+

  this file is generated by ragel from file cat_http_content_type.rl
  do not edit the generated .c manually
  to generate the C file:
    ragel -G2 cat_http_content_type.rl -o cat_http_content_type.c
 */

%%{
    machine cat_media_type;

    write data;

    action in_boundary {
        // printf("in boundary %c\n", *p);
        parser->multipart.boundary_length = 2;
        parser->multipart.multipart_boundary[0] = '-';
        parser->multipart.multipart_boundary[1] = '-';
    }

    action on_boundary {
        // printf("on boundary %c\n", *p);
        if (parser->multipart.boundary_length < 72) {
            parser->multipart.multipart_boundary[parser->multipart.boundary_length++] = *p;
        } else {
            // boundary too long or already have a boundary
            parser->multipart.boundary_length=255;
        }
    }

    action ok {
        ret = cat_true;
        if (parser->multipart.boundary_length > 72) {
            ret = cat_false;
        }
        goto _out;
    }

    action print{
        printf("err \"%c\"\n", *p);
    }

    ows      = [ \t]*;
    obs_text = [\x80-\xff];
    vchar    = [\x1f-\x7e];
    tchar    = "!" | "#" | "$" | "%" | "&" | "'" | "*" | "+" | "-" | "." | "^" | "_" | "`" | "|" | "~" | [0-9a-zA-Z];

    qdtext         = [\t] | [ ] | [\x21] | [\x23-\x5b] | [\x5d-\x7e] | obs_text;
    quoted_pair    = "\\" ( [\t] | [ ] | vchar | obs_text );
    quoted_string  = ["] ( qdtext | quoted_pair )* ["];

    token = tchar +;

    bcharsnospace = digit | alpha | "'" | "(" | ")" |
                    "+" | "_" | "," | "-" | "." |
                    "/" | ":" | "=" | "?";
    bchars = bcharsnospace | " ";
    boundary = (bchars* bcharsnospace) >in_boundary $on_boundary;
    boundary_parameter = /boundary/i "=" (["] boundary ["] | boundary);

    parameter_name  = token - /boundary/i;
    parameter_value = ( token | quoted_string )*;
    parameter       = boundary_parameter | parameter_name "=" parameter_value;
    parameters      = ( ows ";" ows parameter* )*;

    main := /multipart/i "/" (^space)+ parameters %ok;
}%%

static cat_always_inline void cat_http_parser_multipart_parse_content_type_init(cat_http_parser_t *parser) {
    int cs;
    %% write init;
    parser->header_value_parser_state = cs;
    parser->multipart.boundary_length = 0;
    parser->multipart.multipart_boundary[0] = 0;
}

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
#endif
static cat_always_inline cat_bool_t cat_http_parser_multipart_parse_content_type(
    cat_http_parser_t *parser,
    const char *p,
    const char *pe,
    const char *eof
) {
    int cs = parser->header_value_parser_state;
    cat_bool_t ret = cat_false; 
    %% write exec;
    parser->header_value_parser_state = cs;
    return ret;
}
#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif
