/*
  +--------------------------------------------------------------------------+
  | libcat                                                                   |
  +--------------------------------------------------------------------------+
  | Licensed under the Apache License, Version 2.0 (the "License");          |
  | you may not use this file except in compliance with the License.         |
  | You may obtain a copy of the License at                                  |
  | http://www.apache.org/licenses/LICENSE-2.0                               |
  | Unless required by applicable law or agreed to in writing, software      |
  | distributed under the License is distributed on an "AS IS" BASIS,        |
  | WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
  | See the License for the specific language governing permissions and      |
  | limitations under the License. See accompanying LICENSE file.            |
  +--------------------------------------------------------------------------+
  | Author: Twosee <twosee@php.net>                                          |
  |         dixyes <dixyes@gmail.com>                                        |
  +--------------------------------------------------------------------------+

  this file is generated by ragel from file cat_http_content_type.rl
  do not edit the generated .c manually
  to generate the C file:
    ragel -G2 cat_http_content_type.rl -o cat_http_content_type.c
 */

#ifndef HAVE_LIBCAT

#include <stdbool.h>
#include <stdio.h>
#include <string.h>
#include <stdint.h>

typedef struct multipart_parser {
    /* private holder for callbacks */
    const void *settings;
    /* private internal index for matching boundary */
    size_t index;
    /* public error unexpected char index */
    size_t error_i;
    /* private boundary length + 2 ("--") */
    unsigned char boundary_length;
    /* private FSM state */
    unsigned char state;
    /* public error reason */
    unsigned char error_reason;
    /* private boundary storage: "--" + boundary */
    char multipart_boundary[(2 + 70)*2 + 9];
    /* public error expected char */
    char error_expected;
    /* public error unexpected char */
    char error_unexpected;
    /* public triggered */
    char event_triggered;
} multipart_parser;

typedef struct cat_http_parser_s {
    int header_value_parser_state;
    multipart_parser multipart;
} cat_http_parser_t;
typedef bool cat_bool_t;
#define cat_true true
#define cat_false false
#define cat_always_inline inline
#endif

%%{
    machine cat_media_type;

    write data;

    action in_boundary {
        // printf("in boundary %c\n", *p);
        parser->multipart.boundary_length = 2;
        parser->multipart.multipart_boundary[0] = '-';
        parser->multipart.multipart_boundary[1] = '-';
    }

    action on_boundary {
        // printf("on boundary %c\n", *p);
        if (parser->multipart.boundary_length < 72) {
            parser->multipart.multipart_boundary[parser->multipart.boundary_length++] = *p;
        } else {
            // boundary too long or already have a boundary
            parser->multipart.boundary_length=255;
        }
    }

    action ok {
        ret = cat_true;
        if (parser->multipart.boundary_length > 72) {
            ret = cat_false;
        }
        goto _out;
    }

    action print{
        printf("err \"%c\"\n", *p);
    }

    ows      = [ \t]*;
    obs_text = [\x80-\xff];
    vchar    = [\x1f-\x7e];
    tchar    = "!" | "#" | "$" | "%" | "&" | "'" | "*" | "+" | "-" | "." | "^" | "_" | "`" | "|" | "~" | [0-9a-zA-Z];

    qdtext         = [\t] | [ ] | [\x21] | [\x23-\x5b] | [\x5d-\x7e] | obs_text;
    quoted_pair    = "\\" ( [\t] | [ ] | vchar | obs_text );
    quoted_string  = ["] ( qdtext | quoted_pair )* ["];

    token = tchar +;

    bcharsnospace = digit | alpha | "'" | "(" | ")" |
                    "+" | "_" | "," | "-" | "." |
                    "/" | ":" | "=" | "?";
    bchars = bcharsnospace | " ";
    boundary = (bchars* bcharsnospace) >in_boundary $on_boundary;
    boundary_parameter = /boundary/i "=" (["] boundary ["] | boundary);

    parameter_name  = token - /boundary/i;
    parameter_value = ( token | quoted_string )*;
    parameter       = boundary_parameter | parameter_name "=" parameter_value;
    parameters      = ( ows ";" ows parameter* )*;

    main := /multipart/i "/" (^space)+ parameters %ok;
}%%

static cat_always_inline void cat_http_parser_multipart_parse_content_type_init(cat_http_parser_t *parser) {
    int cs;
    %% write init;
    parser->header_value_parser_state = cs;
    parser->multipart.boundary_length = 0;
    parser->multipart.multipart_boundary[0] = 0;
}

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
static cat_always_inline cat_bool_t cat_http_parser_multipart_parse_content_type(
    cat_http_parser_t *parser,
    const char *p,
    const char *pe,
    const char *eof
) {
    int cs = parser->header_value_parser_state;
    cat_bool_t ret = cat_false; 
    %% write exec;
    parser->header_value_parser_state = cs;
    return ret;
}
#pragma GCC diagnostic pop

#ifndef HAVE_LIBCAT

int main() {
    const char * corpora[] = {
        "text/plain",
        "not /good",
        "",
        "noslash",
        "Text/Plain; coding=utf4",
        "multipart/form-data; coding=utf4",
        "multipart/form-data; coding=utf4; boundary=dasd",
        "multipart/form-data; coding=utf4;",
        "multipArt/form-data; coding=utf4,",
        "MULTIPART/form-data; coding=\"utf4\"; boundary=e=mc^2",
        "MULTIPART/form-data; coding=\"utf4\"; boundary=das d",
        "MULTIPART/form-data; coding=\"utf4\"; boundary=\"das d\"",
        "MULTIPART/form-data; coding=\"utf4\"; boundary=\"das d\" ",
        "MULTIPART/form-data; coding=\"utf4\"; boundary=\"das d\" \t",
        "MULTIPART/form-data; coding=\"utf4\"; boundary=\"das d",
        "MULTIPART/form-data; boundary=\""
            "1234567890"
            "2234567890"
            "3234567890"
            "4234567890"
            "5234567890"
            "6234567890"
            "7234567890"
        "\"",
        "MULTIPART/form-data; boundary=\""
            "1234567890"
            "2234567890"
            "3234567890"
            "4234567890"
            "5234567890"
            "6234567890"
            "7234567890"
            "out of range"
        "\"",
    };
    cat_http_parser_t parser;
    for (int i = 0; i < (sizeof(corpora) / sizeof(corpora[0])); i++) {
        cat_http_parser_multipart_parse_content_type_init(&parser);
        const char * corpus = corpora[i];
        int ret = cat_http_parser_multipart_parse_content_type(&parser, corpus, corpus + strlen(corpus), corpus + strlen(corpus));
        printf("%s: ", corpus);
        printf("%d\n", ret);
        printf("%zu %.*s\n", parser.multipart.boundary_length, parser.multipart.boundary_length, parser.multipart.multipart_boundary);
    }

    return 0;
}
#endif
